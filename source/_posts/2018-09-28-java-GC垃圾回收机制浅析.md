---
title: java GC垃圾回收机制浅析
date: 2018-09-28 15:38:55
categories: blog
toc: true
tags:
  - java
  - GC
---
java GC(Garbage Collection 垃圾回收)机制是java语言与C、C++语言的区别之一，java程序员不用主动管理内存，而完全交给了GC去处理，至于到底什么时候执行GC也不是由程序员控制的，而是由java的GC线程去处理，虽然无法控制GC，但是了解GC的机制和工作原理，对于开发健壮可用的应用程序很有帮助。

### 分代内存
java GC主要是发生在堆内存中，而堆内存往往是new对象发生的地方，根据对象实例存货时间将堆内存主要划分成了两个区域，新生代（Young Generation）和老年代（Old Generation）。

![GC分代图](/assets/img/GC.png)

<!--more-->

#### 年轻代 Young Generation
对象被创建时，内存分配首先发生在年轻代（大对象直接进入老年代），大部分对象很快变得不可用，于是会被年轻代的GC机制清理掉。年轻代分为三个区域，按照8:1:1的比例划分，其中伊甸园Eden区域最大，对象创建时首先会被分配到这个区域，当发生GC时会将还在引用的对象依次移动到Survivor区域，没有引用的对象内存则被回收。

![年轻代GC](/assets/img/young.png)

1.绝大多数对象实例创建时分配在Eden伊甸园，其中大多数对象实例会很快消失，不在被引用。Eden内存是连续的所以分配速度很快。

2.最初依次，当Eden伊甸园的内存空间被占满时，年轻代的会执行GC机制Minor GC，清理掉不被引用的对象实例，释放内存，而还在引用的存活实例会被复制到Survivor 1的内存空间，此时Survivor 2的内存空间还是空的。

3.下次Eden伊甸园空间占满时，再次执行Minor GC,将存活的复制移动到Survivor 2中，清空Eden伊甸园的内存空间。

4.将Survivor 1中不被引用的对象实例清理掉，还存活的实例复制到Survivor 2中，清空Survivor 1的内存空间。

5.当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。

#### 老年代 Old Generation
对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）.

#### 永久代 Permanent Generation
永久代也就是我们常说的方法区，方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区也是物理连续的内存空间，这里的垃圾回收发生的很少，主要是针对常量池的内存回收和对已加载类的卸载。由于方法区回收垃圾条件苛刻困难，效果也不尽人意，所以JDK1.8版本已经取消了永久代。

### 对象引用判断
所有垃圾回收都面临这样的问题，就是如何判断对象不再被引用，只有对象不再被引用，才能释放它所占用的内存空间，达到清理垃圾整理内存的目的。

#### 引用计数法
引用计数法是最直接简单的方法计算对象是否还在被引用，简单来说就是为每个对象增加一个引用计数，当对象增加一个引用的时候引用计数加1，相反的当这个对象的一个引用被释放时减1，如果当对象的引用计数变为0时，表示这个对象已经没有被引用。

+ 优点：简单，直接，不需要暂停整个应用。
+ 缺点：需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；存在循环引用的问题。

#### 可达性算法
在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。

在java中，可以作为GC Root的对象有：
+ 虚拟机栈（栈帧中的本地变量表）中的引用对象
+ 方法区中静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI本地方法的引用对象。
 
### 垃圾回收算法
#### 标记清理法 Mark-Sweep
标记清理法是最简单也是最容易实现的，分为两个阶段，标记阶段从根集合开始扫描，标记所有存活对象，清理阶段再次扫描整个内存空间，清理没有标记的内存空间。这个算法容易实现，但是也容易产生内存碎片，而内存碎片过多会导致后续给大对象分配空间时没有可用的空间导致提前出发新的垃圾回收动作。
 
![标记清理法](/assets/img/markSweep.png)
 
#### 复制算法 Copying
为了解决标记清理算法产生的内存碎片问题，复制算法被提出使用，使用原理是将可用内存空间分成大小相等的两份，每次只使用一份，当一份的空间被使用完之后，将所有存活的对象复制到另一份没有使用的内存中，然后清理之前使用过的内存空间，这样就不会产生内存碎片。
 
![复制算法](/assets/img/copying.png)

#### 标记整理法 Mark-Compact
标记整理法是解决标记清理法产生内存碎片的另一个算法，和标记清理法一样分为两个阶段，首先标记存活对象，然后将存活对象向一段移动，然后清理掉没有被标记的内存。

![标记整理法](/assets/img/markCompact.png)
  
### 垃圾回收器
根据年轻代和老年代的垃圾回收算法不同，垃圾回收器也分为年轻代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。当然还包括了一款全新的、新生代老年代通用的G1收集器。各款收集器的搭配使用如下图所示，其中有连线的代表收集器可以搭配使用，没有连线的收集器表示不能搭配使用。

![垃圾收集器示意图](/assets/img/collector.png)

#### 串行收集器（Serial Collector）
作用于年轻代，单线程进行GC，需要先停止其他线程，也就是常说的stop the world，当年轻代的Eden伊甸园内存空间不足时发生。

#### ParNew（Serial 收集器的多线程版本）
是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。同样需要停止其他线程。

#### 并行收集器（Parallel Scavenge）
并行线程，自适应调整策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算。

#### Serial Old
是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法，在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。

#### Parallel Old
多线程并行，作用于老年代，与Parallel Scavenge类似，使用标记整理算法，不过不同之处在于会将幸存的对象复制到预先准备好的区域，而不是向内存一段移动。

#### CMS（并发-标记-清除）
CMS(Concurrent Mark Sweep)是并发收集的老年代收集器。以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。

#### G1
G1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。

